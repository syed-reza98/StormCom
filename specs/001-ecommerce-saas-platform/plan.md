# Implementation Plan: EcommerceGo SaaS Platform

**Branch**: `001-ecommerce-saas-platform` | **Date**: 2025-10-16 | **Spec**: [spec.md](./spec.md)

## Summary

Building a full-stack multi-tenant e-commerce SaaS platform using Next.js 15 with App Router, TypeScript, Prisma ORM with SQLite for local development (PostgreSQL for production), shadcn/ui components, and Next-Auth for authentication. The platform provides comprehensive admin dashboard for managing products, orders, customers, marketing campaigns, and content.

## Technical Context

**Language/Version**: TypeScript 5.3+ with Next.js 15 (App Router)  
**Framework**: Next.js 15 with React 19  
**Primary Dependencies**: 
- Prisma ORM (SQLite local, PostgreSQL production)
- NextAuth.js v5 for authentication
- shadcn/ui + Radix UI for components
- TailwindCSS for styling
- Zod for validation
- React Hook Form for forms
- Recharts for analytics charts
- React Email + Resend for email
**Storage**: SQLite (local development), PostgreSQL (production), Uploadthing/Vercel Blob for file storage  
**Testing**: Vitest + Testing Library for unit/integration, Playwright for E2E  
**Target Platform**: Web application (desktop, tablet, mobile responsive)  
**Project Type**: Full-stack web application with SSR/SSG capabilities  
**Performance Goals**: 
- Page load < 2s (LCP)
- API response < 500ms (p95)
- Dashboard TTI < 3s
**Constraints**: 
- Multi-tenant data isolation
- GDPR/PCI compliance ready
- 99.9% uptime target
**Scale/Scope**: 
- 10,000+ products per store
- 100 concurrent admin users
- 10+ stores per instance

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- ✅ **Code Quality**: TypeScript strict mode, ESLint, Prettier enforced
- ✅ **Testing Standards**: Unit tests for business logic, E2E for critical flows
- ✅ **User Experience**: Responsive design, loading states, error handling, accessibility (WCAG 2.1 AA)
- ✅ **Performance**: Server Components default, dynamic imports, image optimization, DB query optimization
- ✅ **Security**: NextAuth with proper session management, RBAC, input validation, CSRF protection, SQL injection prevention via Prisma

## Project Structure

### Documentation (this feature)

```
specs/001-ecommerce-saas-platform/
├── spec.md              # Feature specification
├── plan.md              # This file - implementation plan
├── data-model.md        # Database schema and Prisma models
├── architecture.md      # System architecture and design decisions
├── api-contracts.md     # API routes and contracts
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```
ecommercego-saas/
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── (auth)/            # Auth routes (login, register, forgot-password)
│   │   ├── (dashboard)/       # Admin dashboard routes
│   │   │   ├── dashboard/     # Main dashboard
│   │   │   ├── products/      # Product management
│   │   │   ├── orders/        # Order management
│   │   │   ├── customers/     # Customer management
│   │   │   ├── marketing/     # Marketing campaigns
│   │   │   ├── reports/       # Analytics & reports
│   │   │   ├── cms/           # Content management
│   │   │   ├── shipping/      # Shipping configuration
│   │   │   ├── staff/         # User & role management
│   │   │   └── settings/      # Store settings
│   │   ├── api/               # API routes
│   │   │   ├── auth/          # NextAuth endpoints
│   │   │   ├── products/      # Product API
│   │   │   ├── orders/        # Order API
│   │   │   ├── customers/     # Customer API
│   │   │   └── [...etc]/      # Other API endpoints
│   │   └── layout.tsx         # Root layout
│   ├── components/
│   │   ├── ui/                # shadcn/ui components
│   │   ├── dashboard/         # Dashboard-specific components
│   │   ├── products/          # Product components
│   │   ├── orders/            # Order components
│   │   ├── forms/             # Reusable form components
│   │   ├── tables/            # Data table components
│   │   └── charts/            # Chart components
│   ├── lib/
│   │   ├── auth/              # Authentication utilities
│   │   ├── db/                # Database utilities
│   │   │   └── prisma.ts      # Prisma client singleton
│   │   ├── validations/       # Zod schemas
│   │   ├── utils.ts           # Utility functions
│   │   └── constants.ts       # App constants
│   ├── services/              # Business logic layer
│   │   ├── products/          # Product service
│   │   ├── orders/            # Order service
│   │   ├── customers/         # Customer service
│   │   ├── auth/              # Auth service
│   │   └── [...etc]/          # Other services
│   ├── hooks/                 # Custom React hooks
│   │   ├── useProducts.ts
│   │   ├── useOrders.ts
│   │   └── [...etc].ts
│   └── types/                 # TypeScript types
│       ├── api.ts
│       ├── models.ts
│       └── [...etc].ts
├── prisma/
│   ├── schema.prisma          # Prisma schema
│   ├── migrations/            # Database migrations
│   └── seed.ts                # Database seeding
├── public/
│   └── uploads/               # Uploaded files (local dev)
├── tests/
│   ├── unit/                  # Unit tests
│   ├── integration/           # Integration tests
│   └── e2e/                   # Playwright E2E tests
├── .env.local                 # Environment variables (not committed)
├── .env.example               # Environment template
├── next.config.js             # Next.js configuration
├── tailwind.config.ts         # Tailwind configuration
├── tsconfig.json              # TypeScript configuration
├── package.json               # Dependencies
└── README.md                  # Project documentation
```

**Structure Decision**: Full-stack Next.js monorepo with App Router for both admin dashboard and API endpoints. Using Server Components by default for better performance, with Client Components only when needed for interactivity. Multi-tenant isolation enforced at database query level using Prisma middleware.

## Technical Architecture

### Frontend Architecture

**Next.js App Router Pattern**:
- Server Components for data fetching and initial render
- Client Components for interactive features
- Server Actions for mutations
- Route Groups for logical organization
- Parallel Routes for complex layouts

**Component Strategy**:
- shadcn/ui as base component library (built on Radix UI)
- Custom components built on top of shadcn
- Compound component pattern for complex UI
- Headless UI patterns for accessibility

**State Management**:
- Server state via React Server Components
- Client state via React hooks (useState, useReducer)
- Form state via React Hook Form
- URL state via Next.js searchParams
- No global state library initially (add Zustand if needed)

### Backend Architecture

**API Design**:
- RESTful API via Next.js Route Handlers
- Server Actions for form submissions
- Middleware for auth, logging, error handling
- Response standardization
- Rate limiting

**Database Layer**:
- Prisma ORM for type-safe database access
- SQLite for local development (file: ./prisma/dev.db)
- PostgreSQL for production
- Migration-based schema management
- Soft deletes for important entities
- Audit timestamps (createdAt, updatedAt)

**Multi-Tenancy Strategy**:
- Store ID in all tenant-scoped tables
- Prisma middleware to auto-inject storeId filter
- Session includes current storeId
- API routes validate store access
- Database-level row security policies (PostgreSQL)

**Authentication & Authorization**:
- NextAuth.js v5 with credentials provider
- JWT sessions with encrypted cookies
- Role-based permissions (RBAC)
- Permission checks in API routes and middleware
- Password hashing with bcrypt

### Data Flow

```
User Request → Next.js Middleware (auth check) →
  ↓
Server Component / API Route →
  ↓
Service Layer (business logic) →
  ↓
Prisma Client (data access) →
  ↓
SQLite/PostgreSQL Database →
  ↓
Response (JSON / RSC)
```

### File Upload Strategy

**Local Development**: 
- Files stored in public/uploads/
- Direct file system writes
- Path stored in database

**Production**:
- Uploadthing or Vercel Blob for cloud storage
- Presigned URLs for uploads
- CDN distribution

### Email Strategy

- React Email for email templates
- Resend for email delivery (development & production)
- Fallback to console logging in dev mode
- Queue for async email sending (future: BullMQ)

## Database Schema (Prisma)

### Core Models

```prisma
// Authentication & Users
model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified DateTime?
  password      String    // hashed with bcrypt
  image         String?
  roleId        String
  role          Role      @relation(fields: [roleId], references: [id])
  storeId       String
  store         Store     @relation(fields: [storeId], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Role {
  id          String   @id @default(cuid())
  name        String
  permissions Json     // Array of permission strings
  users       User[]
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id])
}

// Multi-Tenancy
model Store {
  id        String    @id @default(cuid())
  name      String
  slug      String    @unique
  domain    String?   @unique
  logo      String?
  settings  Json      // Store configuration
  ownerId   String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  users     User[]
  roles     Role[]
  products  Product[]
  orders    Order[]
  customers Customer[]
  // ... other relations
}

// Product Management
model Product {
  id            String           @id @default(cuid())
  name          String
  slug          String
  description   String?
  price         Decimal          @db.Decimal(10, 2)
  salePrice     Decimal?         @db.Decimal(10, 2)
  sku           String
  stockQuantity Int              @default(0)
  stockStatus   StockStatus      @default(IN_STOCK)
  categoryId    String?
  category      Category?        @relation(fields: [categoryId], references: [id])
  brandId       String?
  brand         Brand?           @relation(fields: [brandId], references: [id])
  storeId       String
  store         Store            @relation(fields: [storeId], references: [id])
  images        ProductImage[]
  variants      ProductVariant[]
  labels        ProductLabel[]
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  @@unique([storeId, slug])
  @@unique([storeId, sku])
}

model Category {
  id        String     @id @default(cuid())
  name      String
  slug      String
  parentId  String?
  parent    Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children  Category[] @relation("CategoryHierarchy")
  products  Product[]
  storeId   String
  store     Store      @relation(fields: [storeId], references: [id])
  
  @@unique([storeId, slug])
}

// Order Management
model Order {
  id              String        @id @default(cuid())
  orderNumber     String        @unique
  customerId      String
  customer        Customer      @relation(fields: [customerId], references: [id])
  subtotal        Decimal       @db.Decimal(10, 2)
  tax             Decimal       @db.Decimal(10, 2)
  shippingCost    Decimal       @db.Decimal(10, 2)
  total           Decimal       @db.Decimal(10, 2)
  status          OrderStatus   @default(PENDING)
  paymentStatus   PaymentStatus @default(PENDING)
  items           OrderItem[]
  storeId         String
  store           Store         @relation(fields: [storeId], references: [id])
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model OrderItem {
  id          String          @id @default(cuid())
  orderId     String
  order       Order           @relation(fields: [orderId], references: [id])
  productId   String
  product     Product         @relation(fields: [productId], references: [id])
  variantId   String?
  variant     ProductVariant? @relation(fields: [variantId], references: [id])
  quantity    Int
  unitPrice   Decimal         @db.Decimal(10, 2)
  total       Decimal         @db.Decimal(10, 2)
}

// Enums
enum StockStatus {
  IN_STOCK
  OUT_OF_STOCK
  LOW_STOCK
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  FAILED
}
```

*Note: Full schema with all entities in `data-model.md`*

## API Structure

### REST API Endpoints

**Authentication**:
- `POST /api/auth/signin` - Login
- `POST /api/auth/signout` - Logout
- `POST /api/auth/signup` - Register
- `POST /api/auth/forgot-password` - Password reset request

**Products**:
- `GET /api/products` - List products (with pagination, filters)
- `POST /api/products` - Create product
- `GET /api/products/:id` - Get product details
- `PUT /api/products/:id` - Update product
- `DELETE /api/products/:id` - Delete product
- `POST /api/products/:id/images` - Upload product images

**Orders**:
- `GET /api/orders` - List orders
- `POST /api/orders` - Create order
- `GET /api/orders/:id` - Get order details
- `PUT /api/orders/:id/status` - Update order status
- `POST /api/orders/:id/refund` - Process refund

**Customers**:
- `GET /api/customers` - List customers
- `GET /api/customers/:id` - Get customer details
- `GET /api/customers/:id/orders` - Get customer orders

**Reports**:
- `GET /api/reports/sales` - Sales reports
- `GET /api/reports/inventory` - Inventory reports
- `GET /api/reports/customers` - Customer reports

*Full API documentation in `api-contracts.md`*

## Security Considerations

1. **Authentication**: NextAuth.js with secure session cookies, HTTP-only
2. **Authorization**: RBAC with permission checks on every API route
3. **Input Validation**: Zod schemas for all inputs
4. **SQL Injection**: Prevented via Prisma (parameterized queries)
5. **XSS**: React escapes by default, dangerouslySetInnerHTML only for rich text with sanitization
6. **CSRF**: Next.js built-in CSRF protection
7. **Rate Limiting**: API rate limiting middleware
8. **File Uploads**: Validate file types, size limits, virus scanning
9. **Multi-Tenant Isolation**: Strict store ID filtering at Prisma level
10. **Secrets**: Environment variables, never in code

## Performance Optimizations

1. **Server Components**: Default to Server Components, minimize client JS
2. **Image Optimization**: Next.js Image component with proper sizing
3. **Code Splitting**: Dynamic imports for heavy components
4. **Database**: 
   - Indexes on frequently queried columns
   - Query optimization with Prisma's query analyzer
   - Connection pooling
5. **Caching**: 
   - Next.js built-in caching
   - React Cache for deduped fetches
   - CDN for static assets
6. **Lazy Loading**: Suspense boundaries for non-critical content

## Development Workflow

1. **Local Setup**: 
   ```bash
   npm install
   npm run db:push      # Sync Prisma schema to SQLite
   npm run db:seed      # Seed with sample data
   npm run dev          # Start dev server
   ```

2. **Database Management**:
   ```bash
   npm run db:migrate   # Create migration
   npm run db:studio    # Open Prisma Studio
   npm run db:reset     # Reset database
   ```

3. **Testing**:
   ```bash
   npm run test         # Run unit tests
   npm run test:e2e     # Run E2E tests
   npm run test:coverage # Coverage report
   ```

4. **Code Quality**:
   ```bash
   npm run lint         # ESLint
   npm run format       # Prettier
   npm run type-check   # TypeScript check
   ```

## Deployment Strategy

**Vercel Deployment** (Recommended):
- Push to main branch triggers deployment
- Environment variables configured in Vercel dashboard
- PostgreSQL via Vercel Postgres or Neon
- File storage via Vercel Blob

**Docker Deployment** (Alternative):
- Dockerfile for containerization
- Docker Compose for local multi-container setup
- PostgreSQL as separate container
- Nginx reverse proxy

## Migration from SQLite to PostgreSQL

When moving from local (SQLite) to production (PostgreSQL):

1. Update DATABASE_URL in .env
2. Change provider in schema.prisma from sqlite to postgresql
3. Run `npx prisma migrate dev` to regenerate migrations for PostgreSQL
4. Test all queries (some SQLite-specific syntax may need adjustment)
5. Use Prisma's db push or migrations for production deployment

## Environment Variables

```env
# Database
DATABASE_URL="file:./dev.db"  # SQLite for local
# DATABASE_URL="postgresql://..." # PostgreSQL for production

# NextAuth
NEXTAUTH_SECRET="generate-random-secret"
NEXTAUTH_URL="http://localhost:3000"

# Email
RESEND_API_KEY="your-resend-key"

# File Storage (Production)
UPLOADTHING_SECRET="your-uploadthing-secret"
UPLOADTHING_APP_ID="your-app-id"

# App
NEXT_PUBLIC_APP_URL="http://localhost:3000"
```

## Next Steps

1. Review and approve this plan
2. Run `/speckit.tasks` to generate task breakdown
3. Execute tasks incrementally
4. Test each module as it's built
5. Deploy to production when MVP is complete
